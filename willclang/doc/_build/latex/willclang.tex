% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{willclang Documentation}
\date{December 08, 2011}
\release{0.1}
\author{Will Sheffler}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{Contents}
\label{index:contents}\label{index:welcome-to-willclang-s-documentation}

\section{Intro}
\label{intro:intro}\label{intro::doc}
I am tired of writing complicated regular expressions to try and automate C++ refactoring. There is no fundamental reason we have to spend hundreds of man-hours fixing compile errors at XRW. It's time for some real tools.

This is an attempt at that based on the clang compiler. ATM, it's a bit slow compared to compiling (or grep), but with libclang, it will (eventually) be possible to do refactoring operations \emph{completely} and \emph{correctly} in a turn-key fashion.

\begin{notice}{note}{Todo}

improve speed... removing necessity for parent links and locmap will help
\end{notice}


\section{Requirements}
\label{intro:requirements}

\subsection{Libclang}
\label{intro:libclang}
I got the following from directions here: \href{http://clang.llvm.org/get\_started.html\#build}{http://clang.llvm.org/get\_started.html\#build}

mkdir libclang

cd libclang/

svn co \href{http://llvm.org/svn/llvm-project/llvm/trunk}{http://llvm.org/svn/llvm-project/llvm/trunk} llvm

cd llvm/tools/

svn co \href{http://llvm.org/svn/llvm-project/cfe/trunk}{http://llvm.org/svn/llvm-project/cfe/trunk} clang

cd ../..

mkdir build

cd build/

../llvm/configure

make -j8 ENABLE\_OPTIMIZED=1

\# clang is here: build/Release+Asserts/bin/clang++

\# libclang is here: build/Release+Asserts/lib

export LD\_LIBRARY\_PATH=/PATH\_TO\_LIBCLANG/build/Release+Asserts/lib:LD\_LIBRARY\_PATH

export PYTHONPATH=/PATH\_TO\_LIBCLANG/llvm/tools/clang/bindings/python:PYTHONPATH


\subsection{Sphinx}
\label{intro:sphinx}
for documentation, you need sphinx, which is the defacto python doc tool.

sudo pip install sphinx

or, if you don't have pip `sudo easy\_install sphinx', but you should really really get pip (sudo easy\_install pip will do it)

anything checked in really should have up-to-date docs, but you can rebuild docs with:

cd doc; make html


\section{Module Documentation}
\label{code:module-willclang}\label{code::doc}\label{code:module-documentation}\index{willclang (module)}

\subsection{Util}
\label{code:util}\label{code:module-willclang.util}\index{willclang.util (module)}\index{dir2ns() (in module willclang.util)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.util.dir2ns}\pysiglinewithargsret{\code{willclang.util.}\bfcode{dir2ns}}{\emph{fname}, \emph{checkfs=True}}{}
get namespace corresponding to dir

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{fname} \PYG{o}{=} \PYG{l+s}{"}\PYG{l+s}{/SOME\PYGZus{}DIRECTORY/SOME\PYGZus{}OTHER\PYGZus{}DIR/rosetta\PYGZus{}source/src/core/pack/task}\PYG{l+s}{"}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{dir2ns}\PYG{p}{(}\PYG{n}{fname}\PYG{p}{,}\PYG{n}{checkfs}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{g+go}{'core::pack::task'}
\end{Verbatim}

\end{fulllineitems}

\index{rosbase() (in module willclang.util)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.util.rosbase}\pysiglinewithargsret{\code{willclang.util.}\bfcode{rosbase}}{\emph{fname}, \emph{checkfs=True}}{}
get the rosetta-relative path

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{fname} \PYG{o}{=} \PYG{l+s}{"}\PYG{l+s}{/SOME\PYGZus{}DIRECTORY/SOME\PYGZus{}OTHER\PYGZus{}DIR/rosetta\PYGZus{}source/src/core/scoring/methods}\PYG{l+s}{"}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{rosbase}\PYG{p}{(}\PYG{n}{fname}\PYG{p}{,}\PYG{n}{checkfs}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{g+go}{'src/core/scoring/methods'}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{fname} \PYG{o}{==} \PYG{n}{rospath}\PYG{p}{(}\PYG{n}{fname}\PYG{p}{,}\PYG{n}{checkfs}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{o}{+}\PYG{l+s}{"}\PYG{l+s}{/}\PYG{l+s}{"}\PYG{o}{+}\PYG{n}{rosbase}\PYG{p}{(}\PYG{n}{fname}\PYG{p}{,}\PYG{n}{checkfs}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{g+go}{True}
\end{Verbatim}

\end{fulllineitems}

\index{rospath() (in module willclang.util)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.util.rospath}\pysiglinewithargsret{\code{willclang.util.}\bfcode{rospath}}{\emph{fname}, \emph{checkfs=True}}{}
get path to rosetta\_source

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{fname} \PYG{o}{=} \PYG{l+s}{"}\PYG{l+s}{/SOME\PYGZus{}DIRECTORY/SOME\PYGZus{}OTHER\PYGZus{}DIR/rosetta\PYGZus{}source/src/core/scoring}\PYG{l+s}{"}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{rospath}\PYG{p}{(}\PYG{n}{fname}\PYG{p}{,}\PYG{n}{checkfs}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{g+go}{'/SOME\PYGZus{}DIRECTORY/SOME\PYGZus{}OTHER\PYGZus{}DIR/rosetta\PYGZus{}source'}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{fname} \PYG{o}{==} \PYG{n}{rospath}\PYG{p}{(}\PYG{n}{fname}\PYG{p}{,}\PYG{n}{checkfs}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{o}{+}\PYG{l+s}{"}\PYG{l+s}{/}\PYG{l+s}{"}\PYG{o}{+}\PYG{n}{rosbase}\PYG{p}{(}\PYG{n}{fname}\PYG{p}{,}\PYG{n}{checkfs}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{g+go}{True}
\end{Verbatim}

\end{fulllineitems}

\index{swapfwdhh() (in module willclang.util)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.util.swapfwdhh}\pysiglinewithargsret{\code{willclang.util.}\bfcode{swapfwdhh}}{\emph{fn}}{}~
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{swapfwdhh}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{test.hh}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+go}{test.fwd.hh}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{swapfwdhh}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{t/e/s/t.fwd.hh}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+go}{t/e/s/t.hh}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{swapfwdhh}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{test.cc}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+go}{test.cc}
\end{Verbatim}

\end{fulllineitems}



\subsection{LibClangWrap}
\label{code:libclangwrap}\label{code:module-willclang.LibclangWrap}\index{willclang.LibclangWrap (module)}\index{get\_doctest\_file() (in module willclang.LibclangWrap)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.get_doctest_file}\pysiglinewithargsret{\code{willclang.LibclangWrap.}\bfcode{get\_doctest\_file}}{\emph{fn}}{}~
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{get\PYGZus{}doctest\PYGZus{}file}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{types.cc}\PYG{l+s}{"}\PYG{p}{)}      
\PYG{g+go}{'.../willclang/test/types.cc'}
\end{Verbatim}

\end{fulllineitems}

\index{get\_doctest\_ast() (in module willclang.LibclangWrap)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.get_doctest_ast}\pysiglinewithargsret{\code{willclang.LibclangWrap.}\bfcode{get\_doctest\_ast}}{\emph{fn}}{}~
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{get\PYGZus{}doctest\PYGZus{}ast}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{types.cc}\PYG{l+s}{"}\PYG{p}{)}      
\PYG{g+go}{TRANSLATION\PYGZus{}UNIT /Users/sheffl..test/types.cc     'struct MyStru..\PYGZbs{}tMSP msp;\PYGZbs{}n\PYGZcb{}'}
\PYG{g+go}{\textbar{} STRUCT\PYGZus{}DECL MyStruct     'struct MyStruct \PYGZob{}\PYGZcb{}'}
\PYG{g+go}{\textbar{} TYPEDEF\PYGZus{}DECL MSP     'typedef MyStruct MSP'}
\PYG{g+go}{\textbar{} \textbar{} TYPE\PYGZus{}REF struct MyStruct     'MyStruct'}
\PYG{g+go}{\textbar{} FUNCTION\PYGZus{}DECL test\PYGZus{}types     'void test\PYGZus{}typ..\PYGZbs{}tMSP msp;\PYGZbs{}n\PYGZcb{}'}
\PYG{g+go}{\textbar{} \textbar{} COMPOUND\PYGZus{}STMT      '\PYGZob{}\PYGZbs{}n\PYGZbs{}tint i;\PYGZbs{}n..\PYGZbs{}tMSP msp;\PYGZbs{}n\PYGZcb{}'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} DECL\PYGZus{}STMT      'int i;'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} VAR\PYGZus{}DECL i     'int i'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} DECL\PYGZus{}STMT      'int *ip;'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} VAR\PYGZus{}DECL ip     'int *ip'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} DECL\PYGZus{}STMT      'int \& ir(i);'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} VAR\PYGZus{}DECL ir     'int \& ir(i'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} \textbar{} DECL\PYGZus{}REF\PYGZus{}EXPR i     'i'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} DECL\PYGZus{}STMT      'MyStruct m;'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} VAR\PYGZus{}DECL m     'MyStruct m'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} \textbar{} TYPE\PYGZus{}REF struct MyStruct     'MyStruct'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} \textbar{} CALL\PYGZus{}EXPR MyStruct     'm'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} DECL\PYGZus{}STMT      'MyStruct *mp;'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} VAR\PYGZus{}DECL mp     'MyStruct *mp'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} \textbar{} TYPE\PYGZus{}REF struct MyStruct     'MyStruct'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} DECL\PYGZus{}STMT      'MyStruct \&mr(m);'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} VAR\PYGZus{}DECL mr     'MyStruct \&mr(m'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} \textbar{} TYPE\PYGZus{}REF struct MyStruct     'MyStruct'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} \textbar{} DECL\PYGZus{}REF\PYGZus{}EXPR m     'm'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} DECL\PYGZus{}STMT      'MSP msp;'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} VAR\PYGZus{}DECL msp     'MSP msp'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} \textbar{} TYPE\PYGZus{}REF MSP     'MSP'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} \textbar{} CALL\PYGZus{}EXPR MyStruct     'msp'}
\end{Verbatim}

\end{fulllineitems}

\index{print\_raw\_ast() (in module willclang.LibclangWrap)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.print_raw_ast}\pysiglinewithargsret{\code{willclang.LibclangWrap.}\bfcode{print\_raw\_ast}}{\emph{cursor}, \emph{depth=0}}{}~
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ast} \PYG{o}{=} \PYG{n}{get\PYGZus{}doctest\PYGZus{}ast}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{test\PYGZus{}type\PYGZus{}simple.cc}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{print\PYGZus{}raw\PYGZus{}ast}\PYG{p}{(}\PYG{n}{ast}\PYG{o}{.}\PYG{n}{tu}\PYG{o}{.}\PYG{n}{cursor}\PYG{p}{)}                           
\PYG{g+go}{TRANSLATION\PYGZus{}UNIT ...}
\PYG{g+go}{\textbar{}  TYPEDEF\PYGZus{}DECL \PYGZus{}\PYGZus{}int128\PYGZus{}t}
\PYG{g+go}{\textbar{}  TYPEDEF\PYGZus{}DECL \PYGZus{}\PYGZus{}uint128\PYGZus{}t}
\PYG{g+go}{\textbar{}  STRUCT\PYGZus{}DECL \PYGZus{}\PYGZus{}va\PYGZus{}list\PYGZus{}tag}
\PYG{g+go}{\textbar{}  \textbar{}  FIELD\PYGZus{}DECL gp\PYGZus{}offset}
\PYG{g+go}{\textbar{}  \textbar{}  FIELD\PYGZus{}DECL fp\PYGZus{}offset}
\PYG{g+go}{\textbar{}  \textbar{}  FIELD\PYGZus{}DECL overflow\PYGZus{}arg\PYGZus{}area}
\PYG{g+go}{\textbar{}  \textbar{}  FIELD\PYGZus{}DECL reg\PYGZus{}save\PYGZus{}area}
\PYG{g+go}{\textbar{}  TYPEDEF\PYGZus{}DECL \PYGZus{}\PYGZus{}va\PYGZus{}list\PYGZus{}tag}
\PYG{g+go}{\textbar{}  \textbar{}  STRUCT\PYGZus{}DECL \PYGZus{}\PYGZus{}va\PYGZus{}list\PYGZus{}tag}
\PYG{g+go}{\textbar{}  \textbar{}  \textbar{}  FIELD\PYGZus{}DECL gp\PYGZus{}offset}
\PYG{g+go}{\textbar{}  \textbar{}  \textbar{}  FIELD\PYGZus{}DECL fp\PYGZus{}offset}
\PYG{g+go}{\textbar{}  \textbar{}  \textbar{}  FIELD\PYGZus{}DECL overflow\PYGZus{}arg\PYGZus{}area}
\PYG{g+go}{\textbar{}  \textbar{}  \textbar{}  FIELD\PYGZus{}DECL reg\PYGZus{}save\PYGZus{}area}
\PYG{g+go}{\textbar{}  TYPEDEF\PYGZus{}DECL \PYGZus{}\PYGZus{}builtin\PYGZus{}va\PYGZus{}list}
\PYG{g+go}{\textbar{}  \textbar{}  TYPE\PYGZus{}REF \PYGZus{}\PYGZus{}va\PYGZus{}list\PYGZus{}tag}
\PYG{g+go}{\textbar{}  \textbar{}  INTEGER\PYGZus{}LITERAL }
\PYG{g+go}{\textbar{}  VAR\PYGZus{}DECL i}
\PYG{g+go}{\textbar{}  VAR\PYGZus{}DECL ir}
\PYG{g+go}{\textbar{}  \textbar{}  UNEXPOSED\PYGZus{}EXPR i}
\PYG{g+go}{\textbar{}  \textbar{}  \textbar{}  DECL\PYGZus{}REF\PYGZus{}EXPR i}
\PYG{g+go}{\textbar{}  VAR\PYGZus{}DECL ip}
\PYG{g+go}{\textbar{}  \textbar{}  UNARY\PYGZus{}OPERATOR }
\PYG{g+go}{\textbar{}  \textbar{}  \textbar{}  DECL\PYGZus{}REF\PYGZus{}EXPR i}
\PYG{g+go}{\textbar{}  VAR\PYGZus{}DECL ic}
\PYG{g+go}{\textbar{}  \textbar{}  UNEXPOSED\PYGZus{}EXPR i}
\PYG{g+go}{\textbar{}  \textbar{}  \textbar{}  DECL\PYGZus{}REF\PYGZus{}EXPR i}
\end{Verbatim}

\end{fulllineitems}

\index{hashcursor() (in module willclang.LibclangWrap)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.hashcursor}\pysiglinewithargsret{\code{willclang.LibclangWrap.}\bfcode{hashcursor}}{\emph{c}}{}
get a unique string for a cursor

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{n} \PYG{o}{=} \PYG{n}{get\PYGZus{}doctest\PYGZus{}ast}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{test.cc}\PYG{l+s}{"}\PYG{p}{)}\PYG{o}{.}\PYG{n}{root}\PYG{o}{.}\PYG{n}{srcchild}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{hashcursor}\PYG{p}{(}\PYG{n}{n}\PYG{o}{.}\PYG{n}{cursor}\PYG{p}{)}
\PYG{g+go}{'c:@ir'}
\end{Verbatim}

\end{fulllineitems}

\index{ASTException}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.ASTException}\pysiglinewithargsret{\strong{exception }\code{willclang.LibclangWrap.}\bfcode{ASTException}}{\emph{value}}{}
\end{fulllineitems}



\subsection{SourceFile}
\label{code:sourcefile}
SourceFile class represents a single C++ sourcefile and should hold all data and logic
that doesn'd require parsing at AST
WORK IN PROGRESS!!!
\index{SourceFile (class in willclang.LibclangWrap)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.SourceFile}\pysiglinewithargsret{\strong{class }\code{willclang.LibclangWrap.}\bfcode{SourceFile}}{\emph{fname}, \emph{clangargs=None}}{}
SourceFile holds an individual C++ sourcefile
this should eventually include non-ast locic to do things fast, if possible
resort to ast only if necessary

\end{fulllineitems}

\index{RosettaSourceFile (class in willclang.LibclangWrap)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.RosettaSourceFile}\pysiglinewithargsret{\strong{class }\code{willclang.LibclangWrap.}\bfcode{RosettaSourceFile}}{\emph{fname}}{}
Same as SourceFile, except sepcifies rosetta includes for clang

\end{fulllineitems}



\subsection{AST}
\label{code:ast}\index{AST (class in willclang.LibclangWrap)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.AST}\pysiglinewithargsret{\strong{class }\code{willclang.LibclangWrap.}\bfcode{AST}}{\emph{src}, \emph{clangargs=None}}{}
Wrapper of libclang ast

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ast} \PYG{o}{=} \PYG{n}{get\PYGZus{}doctest\PYGZus{}ast}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{test.cc}\PYG{l+s}{"}\PYG{p}{)}
\end{Verbatim}
\index{check() (willclang.LibclangWrap.AST method)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.AST.check}\pysiglinewithargsret{\bfcode{check}}{}{}
consistency check for ast

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ast} \PYG{o}{=} \PYG{n}{get\PYGZus{}doctest\PYGZus{}ast}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{bad.cc}\PYG{l+s}{"}\PYG{p}{)}               
\PYG{g+gt}{Traceback (most recent call last):}
\PYG{g+gr}{ASTException: "Parse failed from Errors:...Error}: \PYG{n}{no member named 'not\PYGZus{}func' in namespace 'foo::bar' AT .../test/bad.cc line 13 col 38"}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ast} \PYG{o}{=} \PYG{n}{get\PYGZus{}doctest\PYGZus{}ast}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{test.cc}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ast}\PYG{o}{.}\PYG{n}{root}\PYG{o}{.}\PYG{n}{allchild}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{fname} \PYG{o}{=} \PYG{l+s}{"}\PYG{l+s}{Nonsense}\PYG{l+s}{"}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ast}\PYG{o}{.}\PYG{n}{check}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gt}{Traceback (most recent call last):}
    \PYG{k}{assert} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{fname} \PYG{o}{==} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{cursor}\PYG{o}{.}\PYG{n}{location}\PYG{o}{.}\PYG{n}{file}\PYG{p}{)}
\PYG{g+gr}{AssertionError}
\end{Verbatim}

\end{fulllineitems}

\index{check\_tu() (willclang.LibclangWrap.AST method)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.AST.check_tu}\pysiglinewithargsret{\bfcode{check\_tu}}{}{}
check for parse errors

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ast} \PYG{o}{=} \PYG{n}{get\PYGZus{}doctest\PYGZus{}ast}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{bad.cc}\PYG{l+s}{"}\PYG{p}{)}               
\PYG{g+gt}{Traceback (most recent call last):}
\PYG{g+gr}{ASTException: "Parse failed from Errors:...Error}: \PYG{n}{no member named 'not\PYGZus{}func' in namespace 'foo::bar' AT .../test/bad.cc line 13 col 38"}
\end{Verbatim}

\end{fulllineitems}

\index{get\_all\_headers() (willclang.LibclangWrap.AST method)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.AST.get_all_headers}\pysiglinewithargsret{\bfcode{get\_all\_headers}}{}{}~
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ast} \PYG{o}{=} \PYG{n}{get\PYGZus{}doctest\PYGZus{}ast}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{test\PYGZus{}fwd.cc}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{ast}\PYG{o}{.}\PYG{n}{get\PYGZus{}all\PYGZus{}headers}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:} \PYG{k}{print} \PYG{n}{i}     
\PYG{g+go}{/.../willclang/test/include/class1.fwd.hh}
\PYG{g+go}{/.../willclang/test/include/class1.hh}
\PYG{g+go}{/.../willclang/test/include/class2.hh}
\PYG{g+go}{/.../willclang/test/include/class3.hh}
\end{Verbatim}

\end{fulllineitems}

\index{get\_necessary\_headers() (willclang.LibclangWrap.AST method)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.AST.get_necessary_headers}\pysiglinewithargsret{\bfcode{get\_necessary\_headers}}{}{}
wrapper for self.root.includes\_used()

\end{fulllineitems}

\index{switch\_to\_fwd() (willclang.LibclangWrap.AST method)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.AST.switch_to_fwd}\pysiglinewithargsret{\bfcode{switch\_to\_fwd}}{\emph{fn}}{}~
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ast} \PYG{o}{=} \PYG{n}{get\PYGZus{}doctest\PYGZus{}ast}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{test\PYGZus{}fwd.cc}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{for} \PYG{n}{h} \PYG{o+ow}{in} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{ast}\PYG{o}{.}\PYG{n}{all\PYGZus{}headers}\PYG{p}{)}\PYG{p}{:} \PYG{k}{print} \PYG{n}{h}                       
\PYG{g+go}{/.../willclang/test/include/class1.fwd.hh}
\PYG{g+go}{/.../willclang/test/include/class1.hh}
\PYG{g+go}{/.../willclang/test/include/class2.hh}
\PYG{g+go}{/.../willclang/test/include/class3.hh}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{for} \PYG{n}{h} \PYG{o+ow}{in} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{ast}\PYG{o}{.}\PYG{n}{all\PYGZus{}headers}\PYG{p}{)}\PYG{p}{:} \PYG{k}{print} \PYG{n}{ast}\PYG{o}{.}\PYG{n}{switch\PYGZus{}to\PYGZus{}fwd}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}          
\PYG{g+go}{/.../willclang/test/include/class1.fwd.hh}
\PYG{g+go}{/.../willclang/test/include/class1.fwd.hh}
\PYG{g+go}{/.../willclang/test/include/class2.hh}
\PYG{g+go}{/.../willclang/test/include/class3.hh}
\end{Verbatim}

\end{fulllineitems}

\index{switch\_to\_hh() (willclang.LibclangWrap.AST method)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.AST.switch_to_hh}\pysiglinewithargsret{\bfcode{switch\_to\_hh}}{\emph{fn}}{}~
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ast} \PYG{o}{=} \PYG{n}{get\PYGZus{}doctest\PYGZus{}ast}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{test\PYGZus{}fwd.cc}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{for} \PYG{n}{h} \PYG{o+ow}{in} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{ast}\PYG{o}{.}\PYG{n}{all\PYGZus{}headers}\PYG{p}{)}\PYG{p}{:} \PYG{k}{print} \PYG{n}{h}                               
\PYG{g+go}{/.../willclang/test/include/class1.fwd.hh}
\PYG{g+go}{/.../willclang/test/include/class1.hh}
\PYG{g+go}{/.../willclang/test/include/class2.hh}
\PYG{g+go}{/.../willclang/test/include/class3.hh}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{for} \PYG{n}{h} \PYG{o+ow}{in} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{ast}\PYG{o}{.}\PYG{n}{all\PYGZus{}headers}\PYG{p}{)}\PYG{p}{:} \PYG{k}{print} \PYG{n}{ast}\PYG{o}{.}\PYG{n}{switch\PYGZus{}to\PYGZus{}hh}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}    
\PYG{g+go}{/.../willclang/test/include/class1.hh}
\PYG{g+go}{/.../willclang/test/include/class1.hh}
\PYG{g+go}{/.../willclang/test/include/class2.hh}
\PYG{g+go}{/.../willclang/test/include/class3.hh}
\end{Verbatim}

\end{fulllineitems}

\index{transitive\_include\_gragh() (willclang.LibclangWrap.AST method)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.AST.transitive_include_gragh}\pysiglinewithargsret{\bfcode{transitive\_include\_gragh}}{\emph{inc\_subset}, \emph{inc\_why=None}}{}
return \{map of headers H to sets of all other headers which provide them\}
find all headers which (possibly transitively) include a header H

\begin{notice}{note}{Todo}

replace the lame Include class with a map or something, no reason for it to exist right now
\end{notice}

\begin{Verbatim}[commandchars=\\\{\}]
\textgreater{}\textgreater{}\textgreater{} ast = get\_doctest\_ast("test\_inc.cc")
\textgreater{}\textgreater{}\textgreater{} necessary\_headers = [str(x.include) for x in ast.tu.get\_includes()]
\textgreater{}\textgreater{}\textgreater{} inodes,inc\_subset = ast.transitive\_include\_gragh(necessary\_headers)
\textgreater{}\textgreater{}\textgreater{} for k in sorted(inodes.keys()):          
...    print os.path.basename(k)
...    for i in sorted(inodes[k]): print "    provided by:",os.path.basename(i)
class1.hh
class2.hh
class3.hh
...
tdefchain1.hh
tdefchain2.hh
    provided by: tdefchain1.hh
tdefchain3.hh
    provided by: tdefchain1.hh
    provided by: tdefchain2.hh
tdefchain4.hh
    provided by: tdefchain1.hh
    provided by: tdefchain2.hh
    provided by: tdefchain3.hh
...
\textgreater{}\textgreater{}\textgreater{} ast.transitive\_include\_gragh(["imaginary\_header.hh"])    
Traceback (most recent call last):
ASTException: 
'Bad inc\_subset! Include: imaginary\_header.hh not referenced in clang parse of: /Users/sheffler/Dropbox/lib/willclang/test/test\_inc.cc!'
\end{Verbatim}

\end{fulllineitems}


\end{fulllineitems}



\subsection{Node}
\label{code:node}\index{Node (class in willclang.LibclangWrap)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.Node}\pysiglinewithargsret{\strong{class }\code{willclang.LibclangWrap.}\bfcode{Node}}{\emph{ast}, \emph{cursor}, \emph{parent=None}}{}
Wrapper of libclang ast `cursor'
\index{allchild (willclang.LibclangWrap.Node attribute)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.Node.allchild}\pysigline{\bfcode{allchild}\strong{ = None}}
all children

\end{fulllineitems}

\index{ast (willclang.LibclangWrap.Node attribute)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.Node.ast}\pysigline{\bfcode{ast}\strong{ = None}}
AST this node belongs to

\end{fulllineitems}

\index{check() (willclang.LibclangWrap.Node method)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.Node.check}\pysiglinewithargsret{\bfcode{check}}{\emph{recursive=True}}{}~
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{node} \PYG{o}{=} \PYG{n}{get\PYGZus{}doctest\PYGZus{}ast}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{test.cc}\PYG{l+s}{"}\PYG{p}{)}\PYG{o}{.}\PYG{n}{root}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{node}\PYG{o}{.}\PYG{n}{check}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{test} \PYG{o}{=} \PYG{n}{node}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{test}\PYG{o}{.}\PYG{n}{allchild}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{allchild}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{fname} \PYG{o}{=} \PYG{l+s}{"}\PYG{l+s}{NONSENSE}\PYG{l+s}{"}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{test}\PYG{o}{.}\PYG{n}{check}\PYG{p}{(}\PYG{n}{recursive}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{test}\PYG{o}{.}\PYG{n}{check}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gt}{Traceback (most recent call last):}
    \PYG{k}{assert} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{fname} \PYG{o}{==} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{cursor}\PYG{o}{.}\PYG{n}{location}\PYG{o}{.}\PYG{n}{file}\PYG{p}{)}
\PYG{g+gr}{AssertionError}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{test} \PYG{o}{=} \PYG{n}{node}         
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{test}\PYG{o}{.}\PYG{n}{allchild}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{allchild} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{test}\PYG{o}{.}\PYG{n}{check}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gt}{Traceback (most recent call last):}
    \PYG{k}{for} \PYG{n}{c} \PYG{o+ow}{in} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{srcchild}\PYG{p}{:} \PYG{k}{assert} \PYG{n}{c} \PYG{o+ow}{in} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{allchild}
\PYG{g+gr}{AssertionError}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{test}\PYG{o}{.}\PYG{n}{fname} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{node}\PYG{o}{.}\PYG{n}{cursor}\PYG{o}{.}\PYG{n}{location}\PYG{o}{.}\PYG{n}{file}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{test}\PYG{o}{.}\PYG{n}{check}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gt}{Traceback (most recent call last):}
    \PYG{k}{assert} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{fname} \PYG{o}{==} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{ast}\PYG{o}{.}\PYG{n}{fname}
\PYG{g+gr}{AssertionError}
\end{Verbatim}

\end{fulllineitems}

\index{children\_of\_type() (willclang.LibclangWrap.Node method)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.Node.children_of_type}\pysiglinewithargsret{\bfcode{children\_of\_type}}{\emph{t}, \emph{recurseall=False}}{}~
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ast} \PYG{o}{=} \PYG{n}{get\PYGZus{}doctest\PYGZus{}ast}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{types.cc}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{for} \PYG{n}{decl} \PYG{o+ow}{in} \PYG{n}{ast}\PYG{o}{.}\PYG{n}{root}\PYG{o}{.}\PYG{n}{children\PYGZus{}of\PYGZus{}type}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{DECL\PYGZus{}STMT}\PYG{l+s}{"}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }   \PYG{k}{print} \PYG{n}{decl}
\PYG{g+go}{DECL\PYGZus{}STMT      'int i;'}
\PYG{g+go}{DECL\PYGZus{}STMT      'int *ip;'}
\PYG{g+go}{DECL\PYGZus{}STMT      'int \& ir(i);'}
\PYG{g+go}{DECL\PYGZus{}STMT      'MyStruct m;'}
\PYG{g+go}{DECL\PYGZus{}STMT      'MyStruct *mp;'}
\PYG{g+go}{DECL\PYGZus{}STMT      'MyStruct \&mr(m);'}
\PYG{g+go}{DECL\PYGZus{}STMT      'MSP msp;'}
\end{Verbatim}

\end{fulllineitems}

\index{code (willclang.LibclangWrap.Node attribute)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.Node.code}\pysigline{\bfcode{code}\strong{ = None}}
Nchild+1 bits of code interdigitated between code owned by children

\end{fulllineitems}

\index{codeline() (willclang.LibclangWrap.Node method)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.Node.codeline}\pysiglinewithargsret{\bfcode{codeline}}{}{}~
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{n} \PYG{o}{=} \PYG{n}{get\PYGZus{}doctest\PYGZus{}ast}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{types.cc}\PYG{l+s}{"}\PYG{p}{)}\PYG{o}{.}\PYG{n}{root}\PYG{o}{.}\PYG{n}{search}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{test\PYGZus{}types}\PYG{l+s}{"}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{n}\PYG{o}{.}\PYG{n}{codeline}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{void test\PYGZus{}types() \PYGZob{}i ...\textbar{} ct \&mr(m);MSP msp;\PYGZcb{}}
\end{Verbatim}

\end{fulllineitems}

\index{cursor (willclang.LibclangWrap.Node attribute)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.Node.cursor}\pysigline{\bfcode{cursor}\strong{ = None}}
clang cursor

\end{fulllineitems}

\index{definition() (willclang.LibclangWrap.Node method)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.Node.definition}\pysiglinewithargsret{\bfcode{definition}}{}{}~
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ast} \PYG{o}{=} \PYG{n}{get\PYGZus{}doctest\PYGZus{}ast}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{test\PYGZus{}ref.cc}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{ast}\PYG{o}{.}\PYG{n}{root}\PYG{o}{.}\PYG{n}{getstr}\PYG{p}{(}\PYG{n}{recurseall}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}                     
\PYG{g+go}{TRANSLATION\PYGZus{}UNIT /.../test\PYGZus{}ref.cc     '\PYGZsh{}include \textless{}tes..sfunc(ms);\PYGZbs{}n\PYGZcb{}'}
\PYG{g+go}{\textbar{} STRUCT\PYGZus{}DECL MyStruct}
\PYG{g+go}{\textbar{} STRUCT\PYGZus{}DECL MyStruct}
\PYG{g+go}{\textbar{} \textbar{} FIELD\PYGZus{}DECL i}
\PYG{g+go}{\textbar{} FUNCTION\PYGZus{}DECL msfunc}
\PYG{g+go}{\textbar{} \textbar{} PARM\PYGZus{}DECL ms}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} TYPE\PYGZus{}REF struct MyStruct}
\PYG{g+go}{\textbar{} \textbar{} COMPOUND\PYGZus{}STMT }
\PYG{g+go}{\textbar{} \textbar{} \textbar{} RETURN\PYGZus{}STMT }
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} UNEXPOSED\PYGZus{}EXPR i}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} \textbar{} MEMBER\PYGZus{}REF\PYGZus{}EXPR i}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} \textbar{} \textbar{} DECL\PYGZus{}REF\PYGZus{}EXPR ms}
\PYG{g+go}{\textbar{} FUNCTION\PYGZus{}DECL func1     'void func1(My..sfunc(ms);\PYGZbs{}n\PYGZcb{}'}
\PYG{g+go}{\textbar{} \textbar{} PARM\PYGZus{}DECL ms     'MyStruct \& ms'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} TYPE\PYGZus{}REF struct MyStruct     'MyStruct'}
\PYG{g+go}{\textbar{} \textbar{} COMPOUND\PYGZus{}STMT      '\PYGZob{}\PYGZbs{}n\PYGZbs{}tint i = msfunc(ms);\PYGZbs{}n\PYGZcb{}'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} DECL\PYGZus{}STMT      'int i = msfunc(ms);'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} VAR\PYGZus{}DECL i     'int i = msfunc(ms)'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} \textbar{} CALL\PYGZus{}EXPR msfunc     'msfunc(ms)'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} \textbar{} \textbar{} UNEXPOSED\PYGZus{}EXPR msfunc     'msfunc'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} \textbar{} \textbar{} \textbar{} DECL\PYGZus{}REF\PYGZus{}EXPR msfunc     'msfunc'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} \textbar{} \textbar{} DECL\PYGZus{}REF\PYGZus{}EXPR ms     'ms'}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ast}\PYG{o}{.}\PYG{n}{root}\PYG{o}{.}\PYG{n}{treeprint}\PYG{p}{(}\PYG{k}{lambda} \PYG{n}{n}\PYG{p}{:} \PYG{n}{n}\PYG{o}{.}\PYG{n}{definition}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{allchild}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)} 
\PYG{g+go}{None}
\PYG{g+go}{\textbar{} STRUCT\PYGZus{}DECL MyStruct}
\PYG{g+go}{\textbar{} STRUCT\PYGZus{}DECL MyStruct}
\PYG{g+go}{\textbar{} \textbar{} FIELD\PYGZus{}DECL i}
\PYG{g+go}{\textbar{} FUNCTION\PYGZus{}DECL msfunc}
\PYG{g+go}{\textbar{} \textbar{} PARM\PYGZus{}DECL ms}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} STRUCT\PYGZus{}DECL MyStruct}
\PYG{g+go}{\textbar{} \textbar{} None}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} None}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} FIELD\PYGZus{}DECL i}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} \textbar{} FIELD\PYGZus{}DECL i}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} \textbar{} \textbar{} PARM\PYGZus{}DECL ms}
\PYG{g+go}{\textbar{} FUNCTION\PYGZus{}DECL func1     'void func1(My..sfunc(ms);\PYGZbs{}n\PYGZcb{}'}
\PYG{g+go}{\textbar{} \textbar{} PARM\PYGZus{}DECL ms     'MyStruct \& ms'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} STRUCT\PYGZus{}DECL MyStruct}
\PYG{g+go}{\textbar{} \textbar{} None}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} None}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} VAR\PYGZus{}DECL i     'int i = msfunc(ms)'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} \textbar{} FUNCTION\PYGZus{}DECL msfunc}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} \textbar{} \textbar{} FUNCTION\PYGZus{}DECL msfunc}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} \textbar{} \textbar{} \textbar{} FUNCTION\PYGZus{}DECL msfunc}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} \textbar{} \textbar{} PARM\PYGZus{}DECL ms     'MyStruct \& ms'}
\end{Verbatim}

\end{fulllineitems}

\index{end (willclang.LibclangWrap.Node attribute)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.Node.end}\pysigline{\bfcode{end}\strong{ = None}}
end position in sourcefile

\end{fulllineitems}

\index{fname (willclang.LibclangWrap.Node attribute)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.Node.fname}\pysigline{\bfcode{fname}\strong{ = None}}
filename of sourcefile this node came from

\end{fulllineitems}

\index{getstr() (willclang.LibclangWrap.Node method)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.Node.getstr}\pysiglinewithargsret{\bfcode{getstr}}{\emph{recursive=True}, \emph{recurseall=False}, \emph{depth=0}}{}
make a printable string from a node

say raw source is this (test2.hh contains ns1::i):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ast} \PYG{o}{=} \PYG{n}{get\PYGZus{}doctest\PYGZus{}ast}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{test2.cc}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{ast}\PYG{o}{.}\PYG{n}{code}                                          
\PYG{g+go}{\PYGZsh{}include \textless{}test2.hh\textgreater{}}
\PYG{g+go}{using namespace ns1;}
\PYG{g+go}{int j = ns1::i;}
\end{Verbatim}

raw ast looks like this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{print\PYGZus{}raw\PYGZus{}ast}\PYG{p}{(}\PYG{n}{ast}\PYG{o}{.}\PYG{n}{tu}\PYG{o}{.}\PYG{n}{cursor}\PYG{p}{)}                             
\PYG{g+go}{TRANSLATION\PYGZus{}UNIT ...}
\PYG{g+go}{\textbar{}  NAMESPACE ns1}
\PYG{g+go}{\textbar{}  \textbar{}  VAR\PYGZus{}DECL i}
\PYG{g+go}{\textbar{}  USING\PYGZus{}DIRECTIVE }
\PYG{g+go}{\textbar{}  \textbar{}  NAMESPACE\PYGZus{}REF ns1}
\PYG{g+go}{\textbar{}  VAR\PYGZus{}DECL j}
\PYG{g+go}{\textbar{}  \textbar{}  UNEXPOSED\PYGZus{}EXPR i}
\PYG{g+go}{\textbar{}  \textbar{}  \textbar{}  DECL\PYGZus{}REF\PYGZus{}EXPR i}
\PYG{g+go}{\textbar{}  \textbar{}  \textbar{}  \textbar{}  NAMESPACE\PYGZus{}REF ns1}
\end{Verbatim}

by default prints only nodes from parsed src file:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{ast}\PYG{o}{.}\PYG{n}{root}\PYG{o}{.}\PYG{n}{getstr}\PYG{p}{(}\PYG{n}{recursive}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,}\PYG{n}{recurseall}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}   
\PYG{g+go}{TRANSLATION\PYGZus{}UNIT ...}
\PYG{g+go}{\textbar{} USING\PYGZus{}DIRECTIVE      'using namespace ns1'}
\PYG{g+go}{\textbar{} \textbar{} NAMESPACE\PYGZus{}REF ns1     'ns1'}
\PYG{g+go}{\textbar{} VAR\PYGZus{}DECL j     'int j = ns1::i'}
\PYG{g+go}{\textbar{} \textbar{} UNEXPOSED\PYGZus{}EXPR i     'ns1::i'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} DECL\PYGZus{}REF\PYGZus{}EXPR i     'ns1::i'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} NAMESPACE\PYGZus{}REF ns1     'ns1'}
\end{Verbatim}

with recursive=False prints only this node

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{ast}\PYG{o}{.}\PYG{n}{root}\PYG{o}{.}\PYG{n}{getstr}\PYG{p}{(}\PYG{n}{recursive}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}                   
\PYG{g+go}{TRANSLATION\PYGZus{}UNIT ...}
\end{Verbatim}

with recurseall, you get lines from included headers (NAMESPACE,VAR\_DECL):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{ast}\PYG{o}{.}\PYG{n}{root}\PYG{o}{.}\PYG{n}{getstr}\PYG{p}{(}\PYG{n}{recursive}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,}\PYG{n}{recurseall}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}    
\PYG{g+go}{TRANSLATION\PYGZus{}UNIT ...}
\PYG{g+go}{\textbar{} NAMESPACE ns1}
\PYG{g+go}{\textbar{} \textbar{} VAR\PYGZus{}DECL i }
\PYG{g+go}{\textbar{} USING\PYGZus{}DIRECTIVE      'using namespace ns1'}
\PYG{g+go}{\textbar{} \textbar{} NAMESPACE\PYGZus{}REF ns1     'ns1'}
\PYG{g+go}{\textbar{} VAR\PYGZus{}DECL j     'int j = ns1::i'}
\PYG{g+go}{\textbar{} \textbar{} UNEXPOSED\PYGZus{}EXPR i     'ns1::i'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} DECL\PYGZus{}REF\PYGZus{}EXPR i     'ns1::i'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} NAMESPACE\PYGZus{}REF ns1     'ns1'}
\end{Verbatim}

\end{fulllineitems}

\index{includes\_used() (willclang.LibclangWrap.Node method)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.Node.includes_used}\pysiglinewithargsret{\bfcode{includes\_used}}{}{}
returns {[}sorted list of includes{]} \{map of nodes which think they need a particular include\}
attempt to find the headers which are actually needed for the core in the sourcefile
in the following example, many headers are included, but only something in tdef3.hh is actually used.

WORK IN PROGRESS!

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ast} \PYG{o}{=} \PYG{n}{get\PYGZus{}doctest\PYGZus{}ast}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{test\PYGZus{}inc.cc}\PYG{l+s}{"}\PYG{p}{)}
\end{Verbatim}

print all headers:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{for} \PYG{n}{h} \PYG{o+ow}{in} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{ast}\PYG{o}{.}\PYG{n}{all\PYGZus{}headers}\PYG{p}{)}\PYG{p}{:} \PYG{k}{print} \PYG{n}{h}            
\PYG{g+go}{/.../willclang/test/include/class1.hh}
\PYG{g+go}{/.../willclang/test/include/class2.hh}
\PYG{g+go}{/.../willclang/test/include/class3.hh}
\PYG{g+go}{/.../willclang/test/include/class4.hh}
\PYG{g+go}{/.../willclang/test/include/def1.hh}
\PYG{g+go}{/.../willclang/test/include/def2.hh}
\PYG{g+go}{/.../willclang/test/include/def3.hh}
\PYG{g+go}{/.../willclang/test/include/def4.hh}
\PYG{g+go}{/.../willclang/test/include/func1.hh}
\PYG{g+go}{/.../willclang/test/include/func2.hh}
\PYG{g+go}{/.../willclang/test/include/func3.hh}
\PYG{g+go}{/.../willclang/test/include/func4.hh}
\PYG{g+go}{/.../willclang/test/include/ns1.hh}
\PYG{g+gp}{... }
\end{Verbatim}

but these aren't all needed, the ast it just this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{ast}\PYG{o}{.}\PYG{n}{root}\PYG{o}{.}\PYG{n}{getstr}\PYG{p}{(}\PYG{p}{)}                               
\PYG{g+go}{TRANSLATION\PYGZus{}UNIT ...}
\PYG{g+go}{\textbar{} VAR\PYGZus{}DECL i     'tdef3 i'}
\PYG{g+go}{\textbar{} \textbar{} TYPE\PYGZus{}REF tdef3     'tdef3'}
\end{Verbatim}

print only headers ``referred'' to in the actual source:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{inc}\PYG{p}{,}\PYG{n}{inc\PYGZus{}why} \PYG{o}{=} \PYG{n}{ast}\PYG{o}{.}\PYG{n}{root}\PYG{o}{.}\PYG{n}{includes\PYGZus{}used}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{for} \PYG{n}{h} \PYG{o+ow}{in} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{inc}\PYG{p}{)}\PYG{p}{:} \PYG{k}{print} \PYG{n}{h}                          
\PYG{g+go}{/.../willclang/test/include/tdef3.hh}
\end{Verbatim}

The node(s) which think they need a particular header are reported in the map `inc\_why' (2nd return):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{for} \PYG{n}{h} \PYG{o+ow}{in} \PYG{n}{inc}\PYG{p}{:}                                          
\PYG{g+gp}{... }   \PYG{k}{print} \PYG{n}{h}
\PYG{g+gp}{... }   \PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n}{inc\PYGZus{}why}\PYG{p}{[}\PYG{n}{h}\PYG{p}{]}\PYG{p}{:}
\PYG{g+gp}{... }       \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{    needed by}\PYG{l+s}{"}\PYG{p}{,}\PYG{n}{n}\PYG{o}{.}\PYG{n}{getstr}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{/.../willclang/test/include/tdef3.hh}
\PYG{g+go}{    needed by TYPE\PYGZus{}REF tdef3     'tdef3'}
\end{Verbatim}

\end{fulllineitems}

\index{is\_decl() (willclang.LibclangWrap.Node method)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.Node.is_decl}\pysiglinewithargsret{\bfcode{is\_decl}}{}{}~
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{def} \PYG{n+nf}{visit}\PYG{p}{(}\PYG{n}{node}\PYG{p}{)}\PYG{p}{:} \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{IS\PYGZus{}DECL:}\PYG{l+s}{"}\PYG{p}{,}\PYG{n}{node}\PYG{o}{.}\PYG{n}{is\PYGZus{}decl}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{node}\PYG{o}{.}\PYG{n}{getstr}\PYG{p}{(}\PYG{n}{recursive}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ast} \PYG{o}{=} \PYG{n}{get\PYGZus{}doctest\PYGZus{}ast}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{types.cc}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ast}\PYG{o}{.}\PYG{n}{root}\PYG{o}{.}\PYG{n}{treemap}\PYG{p}{(}\PYG{n}{visit}\PYG{p}{)} 
\PYG{g+go}{IS\PYGZus{}DECL: False TRANSLATION\PYGZus{}UNIT ...test/types.cc     ...}
\PYG{g+go}{IS\PYGZus{}DECL: False STRUCT\PYGZus{}DECL MyStruct       'struct MyStruct \PYGZob{}\PYGZcb{}'}
\PYG{g+gp}{...}
\PYG{g+go}{IS\PYGZus{}DECL: False DECL\PYGZus{}STMT                  'int i;'}
\PYG{g+go}{IS\PYGZus{}DECL: True  VAR\PYGZus{}DECL i                 'int i'}
\PYG{g+go}{IS\PYGZus{}DECL: False DECL\PYGZus{}STMT                  'int *ip;'}
\PYG{g+go}{IS\PYGZus{}DECL: True  VAR\PYGZus{}DECL ip                'int *ip'}
\PYG{g+go}{IS\PYGZus{}DECL: False DECL\PYGZus{}STMT                  'int \& ir(i);'}
\PYG{g+go}{IS\PYGZus{}DECL: True  VAR\PYGZus{}DECL ir                'int \& ir(i'}
\PYG{g+gp}{...}
\end{Verbatim}

\end{fulllineitems}

\index{is\_ptr\_or\_ref() (willclang.LibclangWrap.Node method)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.Node.is_ptr_or_ref}\pysiglinewithargsret{\bfcode{is\_ptr\_or\_ref}}{}{}
returns True if this node is a reference or pointer type; 
returns False if this node is a non-reference and non-pointer type;     
should return None if not a declaration

WORK IN PROGRESS

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{def} \PYG{n+nf}{visit}\PYG{p}{(}\PYG{n}{node}\PYG{p}{)}\PYG{p}{:} \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{IS\PYGZus{}PtrRef:}\PYG{l+s}{"}\PYG{p}{,}\PYG{n}{node}\PYG{o}{.}\PYG{n}{is\PYGZus{}ptr\PYGZus{}or\PYGZus{}ref}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{node}\PYG{o}{.}\PYG{n}{getstr}\PYG{p}{(}\PYG{n}{recursive}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ast} \PYG{o}{=} \PYG{n}{get\PYGZus{}doctest\PYGZus{}ast}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{types.cc}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ast}\PYG{o}{.}\PYG{n}{root}\PYG{o}{.}\PYG{n}{treemap}\PYG{p}{(}\PYG{n}{visit}\PYG{p}{)}                            
\PYG{g+go}{IS\PYGZus{}PtrRef: None  TRANSLATION\PYGZus{}UNIT ...test/types.cc ...}
\PYG{g+go}{IS\PYGZus{}PtrRef: None  STRUCT\PYGZus{}DECL MyStruct         'struct MyStruct \PYGZob{}\PYGZcb{}'}
\PYG{g+gp}{...}
\PYG{g+go}{IS\PYGZus{}PtrRef: False VAR\PYGZus{}DECL i                   'int i'}
\PYG{g+go}{IS\PYGZus{}PtrRef: None  DECL\PYGZus{}STMT                    'int *ip;'}
\PYG{g+go}{IS\PYGZus{}PtrRef: True  VAR\PYGZus{}DECL ip                  'int *ip'}
\PYG{g+go}{IS\PYGZus{}PtrRef: None  DECL\PYGZus{}STMT                    'int \& ir(i);'}
\PYG{g+go}{IS\PYGZus{}PtrRef: True  VAR\PYGZus{}DECL ir                  'int \& ir(i'}
\PYG{g+go}{IS\PYGZus{}PtrRef: None  DECL\PYGZus{}REF\PYGZus{}EXPR i              'i'}
\PYG{g+go}{IS\PYGZus{}PtrRef: None  DECL\PYGZus{}STMT                    'MyStruct m;'}
\PYG{g+go}{IS\PYGZus{}PtrRef: False VAR\PYGZus{}DECL m                   'MyStruct m'}
\PYG{g+gp}{... }    
\PYG{g+go}{IS\PYGZus{}PtrRef: True  VAR\PYGZus{}DECL mp                  'MyStruct *mp'}
\PYG{g+go}{IS\PYGZus{}PtrRef: None  TYPE\PYGZus{}REF struct MyStruct     'MyStruct'}
\PYG{g+go}{IS\PYGZus{}PtrRef: None  DECL\PYGZus{}STMT                    'MyStruct \&mr(m);'}
\PYG{g+go}{IS\PYGZus{}PtrRef: True  VAR\PYGZus{}DECL mr                  'MyStruct \&mr(m'}
\PYG{g+gp}{...}
\PYG{g+go}{IS\PYGZus{}PtrRef: False VAR\PYGZus{}DECL msp                 'MSP msp'}
\PYG{g+gp}{...}
\end{Verbatim}

\end{fulllineitems}

\index{isdefinition() (willclang.LibclangWrap.Node method)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.Node.isdefinition}\pysiglinewithargsret{\bfcode{isdefinition}}{}{}~
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{def} \PYG{n+nf}{visit}\PYG{p}{(}\PYG{n}{node}\PYG{p}{)}\PYG{p}{:} \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{IS\PYGZus{}DEF:}\PYG{l+s}{"}\PYG{p}{,}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{node}\PYG{o}{.}\PYG{n}{isdefinition}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{ljust}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}\PYG{n}{node}\PYG{o}{.}\PYG{n}{getstr}\PYG{p}{(}\PYG{n}{recursive}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ast} \PYG{o}{=} \PYG{n}{get\PYGZus{}doctest\PYGZus{}ast}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{types.cc}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ast}\PYG{o}{.}\PYG{n}{root}\PYG{o}{.}\PYG{n}{treemap}\PYG{p}{(}\PYG{n}{visit}\PYG{p}{)} 
\PYG{g+go}{IS\PYGZus{}DEF: False TRANSLATION\PYGZus{}UNIT /Users/sheffl..test/types.cc     'struct MyStru..\PYGZbs{}tMSP msp;\PYGZbs{}n\PYGZcb{}'}
\PYG{g+go}{IS\PYGZus{}DEF: True  STRUCT\PYGZus{}DECL MyStruct     'struct MyStruct \PYGZob{}\PYGZcb{}'}
\PYG{g+go}{IS\PYGZus{}DEF: True  TYPEDEF\PYGZus{}DECL MSP     'typedef MyStruct MSP'}
\PYG{g+go}{IS\PYGZus{}DEF: False TYPE\PYGZus{}REF struct MyStruct     'MyStruct'}
\PYG{g+go}{IS\PYGZus{}DEF: True  FUNCTION\PYGZus{}DECL test\PYGZus{}types     'void test\PYGZus{}typ..\PYGZbs{}tMSP msp;\PYGZbs{}n\PYGZcb{}'}
\PYG{g+go}{IS\PYGZus{}DEF: False COMPOUND\PYGZus{}STMT      '\PYGZob{}\PYGZbs{}n\PYGZbs{}tint i;\PYGZbs{}n..\PYGZbs{}tMSP msp;\PYGZbs{}n\PYGZcb{}'}
\PYG{g+go}{IS\PYGZus{}DEF: False DECL\PYGZus{}STMT      'int i;'}
\PYG{g+go}{IS\PYGZus{}DEF: True  VAR\PYGZus{}DECL i     'int i'}
\PYG{g+go}{IS\PYGZus{}DEF: False DECL\PYGZus{}STMT      'int *ip;'}
\PYG{g+go}{IS\PYGZus{}DEF: True  VAR\PYGZus{}DECL ip     'int *ip'}
\PYG{g+gp}{...}
\end{Verbatim}

\end{fulllineitems}

\index{namespace() (willclang.LibclangWrap.Node method)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.Node.namespace}\pysiglinewithargsret{\bfcode{namespace}}{}{}
get the full namespace of any-old-thing. you \emph{can't} do this with grep!

\begin{notice}{note}{Todo}

find another way to get namespace of arbitrary things, because this the parent-reference approach
is really the only reason each node needs a wrapper. this is expensive
\end{notice}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ast} \PYG{o}{=} \PYG{n}{get\PYGZus{}doctest\PYGZus{}ast}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{test\PYGZus{}ns.cc}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{visit} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{x}\PYG{o}{.}\PYG{n}{codeline}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{ IN }\PYG{l+s}{"} \PYG{k}{if} \PYG{n}{x}\PYG{o}{.}\PYG{n}{namespace}\PYG{p}{(}\PYG{p}{)} \PYG{k}{else} \PYG{l+s}{"}\PYG{l+s}{"}\PYG{p}{)} \PYG{o}{+} \PYG{n}{x}\PYG{o}{.}\PYG{n}{namespace}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ast}\PYG{o}{.}\PYG{n}{root}\PYG{o}{.}\PYG{n}{treeprint}\PYG{p}{(}\PYG{n}{visit}\PYG{p}{)}     
\PYG{g+go}{\PYGZsh{}...}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} ns1::val1                     IN ns1                     ...}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} ns1::ns2::val2                IN ns1::ns2                ...}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} ns1::ns2::ns3::val3           IN ns1::ns2::ns3           ...}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} ns1::ns2::ns3::ns4::val4      IN ns1::ns2::ns3::ns4      ...}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} ns1::ns2::ns3::ns4::ns5::val5 IN ns1::ns2::ns3::ns4::ns5 ...}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} using namespace ns1; ...}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} using namespace ns2; ...}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} using namespace ns3; ...}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} val1           IN ns1}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} val2           IN ns1::ns2}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} val3           IN ns1::ns2::ns3}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} ns4::val4      IN ns1::ns2::ns3::ns4      ...}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} ns4::ns5::val5 IN ns1::ns2::ns3::ns4::ns5 ...}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} using namespace ns4; ...}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} using namespace ns5; ...}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} val1 IN ns1}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} val2 IN ns1::ns2}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} val3 IN ns1::ns2::ns3}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} val4 IN ns1::ns2::ns3::ns4}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} val5 IN ns1::ns2::ns3::ns4::ns5}
\end{Verbatim}

\end{fulllineitems}

\index{parent (willclang.LibclangWrap.Node attribute)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.Node.parent}\pysigline{\bfcode{parent}\strong{ = None}}
parent node

\end{fulllineitems}

\index{start (willclang.LibclangWrap.Node attribute)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.Node.start}\pysigline{\bfcode{start}\strong{ = None}}
start position in sourcefile

\end{fulllineitems}

\index{treemap() (willclang.LibclangWrap.Node method)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.Node.treemap}\pysiglinewithargsret{\bfcode{treemap}}{\emph{func}, \emph{allchild=False}}{}~
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{def} \PYG{n+nf}{visit}\PYG{p}{(}\PYG{n}{node}\PYG{p}{)}\PYG{p}{:} \PYG{k}{print} \PYG{n}{node}\PYG{o}{.}\PYG{n}{cursor}\PYG{o}{.}\PYG{n}{location}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ast} \PYG{o}{=} \PYG{n}{get\PYGZus{}doctest\PYGZus{}ast}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{types.cc}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ast}\PYG{o}{.}\PYG{n}{root}\PYG{o}{.}\PYG{n}{treemap}\PYG{p}{(}\PYG{n}{visit}\PYG{p}{)} 
\PYG{g+go}{\textless{}SourceLocation file None, line 0, column 0\textgreater{}}
\PYG{g+go}{\textless{}SourceLocation file '.../willclang/test/types.cc', line 1, column 8\textgreater{}}
\PYG{g+go}{\textless{}SourceLocation file '.../willclang/test/types.cc', line 3, column 18\textgreater{}}
\PYG{g+go}{\textless{}SourceLocation file '.../willclang/test/types.cc', line 3, column 9\textgreater{}}
\PYG{g+go}{\textless{}SourceLocation file '.../willclang/test/types.cc', line 5, column 6\textgreater{}}
\PYG{g+go}{\textless{}SourceLocation file '.../willclang/test/types.cc', line 5, column 19\textgreater{}}
\PYG{g+go}{\textless{}SourceLocation file '.../willclang/test/types.cc', line 6, column 2\textgreater{}}
\PYG{g+go}{\textless{}SourceLocation file '.../willclang/test/types.cc', line 6, column 6\textgreater{}}
\PYG{g+go}{\textless{}SourceLocation file '.../willclang/test/types.cc', line 7, column 2\textgreater{}}
\PYG{g+gp}{...}
\end{Verbatim}

\end{fulllineitems}

\index{treeprint() (willclang.LibclangWrap.Node method)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.Node.treeprint}\pysiglinewithargsret{\bfcode{treeprint}}{\emph{func}, \emph{allchild=False}, \emph{depth=0}}{}~
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ast} \PYG{o}{=} \PYG{n}{get\PYGZus{}doctest\PYGZus{}ast}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{test\PYGZus{}ref.cc}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ast}\PYG{o}{.}\PYG{n}{root}\PYG{o}{.}\PYG{n}{treeprint}\PYG{p}{(}\PYG{k}{lambda} \PYG{n}{n}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{FOO }\PYG{l+s}{"}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{FOO TRANSLATION\PYGZus{}UNIT /Users/sheffl..t/test\PYGZus{}ref.cc     '\PYGZsh{}include \textless{}tes..sfunc(ms);\PYGZbs{}n\PYGZcb{}'}
\PYG{g+go}{\textbar{} FOO FUNCTION\PYGZus{}DECL func1     'void func1(My..sfunc(ms);\PYGZbs{}n\PYGZcb{}'}
\PYG{g+go}{\textbar{} \textbar{} FOO PARM\PYGZus{}DECL ms     'MyStruct \& ms'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} FOO TYPE\PYGZus{}REF struct MyStruct     'MyStruct'}
\PYG{g+go}{\textbar{} \textbar{} FOO COMPOUND\PYGZus{}STMT      '\PYGZob{}\PYGZbs{}n\PYGZbs{}tint i = msfunc(ms);\PYGZbs{}n\PYGZcb{}'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} FOO DECL\PYGZus{}STMT      'int i = msfunc(ms);'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} FOO VAR\PYGZus{}DECL i     'int i = msfunc(ms)'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} \textbar{} FOO CALL\PYGZus{}EXPR msfunc     'msfunc(ms)'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} \textbar{} \textbar{} FOO UNEXPOSED\PYGZus{}EXPR msfunc     'msfunc'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} \textbar{} \textbar{} \textbar{} FOO DECL\PYGZus{}REF\PYGZus{}EXPR msfunc     'msfunc'}
\PYG{g+go}{\textbar{} \textbar{} \textbar{} \textbar{} \textbar{} \textbar{} FOO DECL\PYGZus{}REF\PYGZus{}EXPR ms     'ms'}
\end{Verbatim}

\end{fulllineitems}

\index{update\_srcchild() (willclang.LibclangWrap.Node method)}

\begin{fulllineitems}
\phantomsection\label{code:willclang.LibclangWrap.Node.update_srcchild}\pysiglinewithargsret{\bfcode{update\_srcchild}}{}{}
updates list of same-srcfile children

\end{fulllineitems}


\end{fulllineitems}



\section{Tests}
\label{tests:tests}\label{tests::doc}

\subsection{doctest}
\label{tests:doctest}
doctest is really sweet... just put example code in your docstrings, and doctest will run it. all the tests I've written are done this way, and they double as nice documentation!


\subsection{unittests}
\label{tests:unittests}
nose? py.test? unitest2? or is doctest sufficient?
s


\section{TODOs}
\label{todo::doc}\label{todo:todos}
\begin{notice}{note}{Todo}

replace the lame Include class with a map or something, no reason for it to exist right now
\end{notice}

(The {\hyperref[code:index-0]{\emph{original entry}}} is located in  /Users/sheffler/lib/willclang/LibclangWrap.py:docstring of willclang.LibclangWrap.AST.transitive\_include\_gragh, line 4.)

\begin{notice}{note}{Todo}

find another way to get namespace of arbitrary things, because this the parent-reference approach
is really the only reason each node needs a wrapper. this is expensive
\end{notice}

(The {\hyperref[code:index-1]{\emph{original entry}}} is located in  /Users/sheffler/lib/willclang/LibclangWrap.py:docstring of willclang.LibclangWrap.Node.namespace, line 3.)

\begin{notice}{note}{Todo}

improve speed... removing necessity for parent links and locmap will help
\end{notice}

(The {\hyperref[intro:index-0]{\emph{original entry}}} is located in  /Users/sheffler/Dropbox/lib/willclang/doc/intro.rst, line 8.)


\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{w}
\item {\texttt{willclang}}, \pageref{code:module-willclang}
\item {\texttt{willclang.LibclangWrap}}, \pageref{code:module-willclang.LibclangWrap}
\item {\texttt{willclang.util}}, \pageref{code:module-willclang.util}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
